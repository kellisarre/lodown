'use strict';

// LODOWN-kellisarre Documentation //

/***
 * identity: Simply returns the unchanged argument.
 * 
 * @param anything: The input to be returned.
 * 
 * @return: Outputs the argument, unchanged.
 * 
 * Usage:
 *          _.each([1, 2, 3], _.identity); // -> [1, 2, 3] 
 */

identity = function(anything) {
    return anything;
}

module.exports.identity = identity;

/**
 * typeOf:  Designed to identify the JS datatype of the argument.
 *          Fixes a few non-meaningful type returns generated by native typeof operator.
 * 
 * 
 * @param anything: The data whose type to determine.
 * 
 * @return {String}: A string value to represent the datatype.
 *                  Types are one of:
 *                      - "string"
 *                      - "array"
 *                      - "object"
 *                      - "undefined"
 *                      - "number"
 *                      - "boolean"
 *                      - "null"
 *                      - "function"
 * Usage: 
 *          _.typeOf("thing"); // -> 'string'
 *          _.typeOf([1, 2, 3]); // -> 'array'
 *          _.typeOf(console.log) // -> 'function'
 */

typeOf = function(anything) {
    if (Array.isArray(anything)) {
        return 'array';
    }
    else if (anything === null) {
        return 'null';
    }
    else {
        return typeof anything;
    }
}

module.exports.typeOf = typeOf;

/**
 * first: Returns a slice containing the first number of items in the <array>.
 * 
 * @param {Array} array: Array to iterate.
 * @param {Number} number: Number of items to retrieve from front of array.
 * 
 * @return: An array containing the first number of elements in the array if 
 *          the arguments passed are of the correct type. 
 *          - If a negative integer is supplied as number argument or array is
 *          not given, returns an empty array.
 *          - If <number> is not a number, returns first array element.
 *          - If <number> is greater than the length of the array, returns whole array.
 * 
 * Usage: 
 *          console.log(first([7,8,9,65], 3)); // -> [7, 8, 9]
 *          console.log(first("kittens", 1)) // -> []
 *          console.log(first([7,8,9,65], -1)) // -> []
 *          console.log(first([7,8,9,63], "kittens")); // -> 7
 */

first = function(array, number) {
    if (Array.isArray(array)) {
        if (typeof number === "number" && number > 0) {
            return array.slice(0, number);
        }
        else if (typeof number !== "number") {
            return array[0];
        }
        else {
            return [];
        }
    }
    else {
        return [];
    }
}

module.exports.first = first;

/** last: Returns a slice containing the last number of items in the array.
 * 
 * @param {Array} array: Array to iterate.
 * @param {Number} number: Number of items to retrieve from back of array.
 * 
 * @return: An array containing the last number of elements in the array if the arguments passed
 *          are of the correct type. 
 *          - If a negative integer is supplied as <number> argument or <array> is
 *          not given, returns an empty array.
 *          - If <number> is not a number, returns last array element.
 *          - If <number> is greater than the length of the array, returns whole array.
 * 
 * Usage: 
 *          console.log(last([7,8,9,65], 1)); // -> [65]
 *          console.log(last([7,8,9,65], "kittens")); // -> 65
 *          console.log(last("kittens", 1)); // -> []
 *          console.log(last([7,8,9,65], -1)); // -> []
 */

last = function(array, number) {
    if (Array.isArray(array)) {
        if (number > array.length) {
            return array;
        }
        if (typeof number === "number" && number > 0) {
            return array.slice((array.length - number), array.length);
        }
        else if (typeof number !== "number") {
            return array[array.length - 1];
        }
        else {
            return [];
        }
    }
    else {
        return [];
    }
}

module.exports.last = last;

/**
 * each: Designed to loop over a collection, Array or Object, and applies the 
 * action Function to each value in the collection.
 * 
 * @param {Array or Object} collection: The collection over which to iterate.
 * @param {Function} action: The Function to be applied to each value in the 
 * 
 */
each = function(collection, action) {
    if (Array.isArray(collection)) {
        for (let i = 0; i < collection.length; i++) {
            action(collection[i], i, collection);
        }
    }
    else if (typeOf(collection) === "object") {
        for (var key in collection) {
            action(collection[key], key, collection);
        }
    }
}
module.exports.each = each;

/** 
 * indexOf: Designed to return the index of the value's first occurace. 
 *          Returns -1 if the value doesn't exist in the array.
 * 
 * @param {Array} array: The array to iterate. 
 * @param value: The value to find.
 * 
 * @return {Number}: Returns the index number of the value or -1 if the specified 
 *                  value is not in the array.
 * 
 */


indexOf = function(array, value) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
}

module.exports.indexOf = indexOf;

/** 
 * filter: Designed to filter values in a collection based on a test. 
 * Values that pass the test are collected and returned in an output Array.
 * 
 * @param {Array or Object} collection: The collection to filter.
 * @param {Function} test: The Function to be applied to each value in 
 * the collection. The test Function must return a Boolean. If the returned value
 * is true, it will be added to filter's returned array.
 * 
 * @return {Array}: An Array containing the filtered collection values. 
 * The Array will contain only the values that passed the test.
 * 
 * Usage: 
 * 
 *      const letters = ['a', 'b', 'b', 'c'];
 *      const onlyBs = _.filter(letters, function(letter) {
 *          return letter === 'b';
 *      });
 *      console.log(onlyBs); // -> ['b', 'b']
 */
 
filter = function(array, test) {
    let newArray = [];
    // perform action on each element in <array> 
    for (let i = 0; i < array.length; i++) {
        if (test(array[i], i, array)) {
            newArray.push(array[i]);
        }
    }
    return newArray;
}
 module.exports.filter = filter;

/** 
 * reject: Reject will produce a new array of rejected elements that 
 * did not meet the test criteria.
 * 
 * @param {Array or Object} collection: The collection to filter.
 * @param {Function} test: The Function to be applied to each value in 
 * the collection. The test Function must return a Boolean. Falsies will be
 * added to reject's returned array.
 * 
 * @return {Array}: An Array containing the rejected collection values. 
 * The Array will contain only the values that were evaluated to be false.
 * 
 * Usage: 
 * 
 *      const letters = ['a', 'b', 'b', 'c'];
 *      const notBs = _.reject(letters, function(letter) {
 *          return letter === 'b';
 *      });
 *      console.log(notBs); // -> ['a', 'c']
 * 
 * 
 *      _.reject([1,2,3,4,5], function(e){return e%2 === 0}) // -> [1,3,5]
 */

reject = function(array, test) {
    let newArray = [];
    // perform action on each element in <array> 
    for (let i = 0; i < array.length; i++) {
        if (test(array[i], i, array) === false) {
            newArray.push(array[i]);
        }
    }
    return newArray;
}

module.exports.reject = reject;


/** partition:  Tests each element in an array and returns an array with the values
 *              divided into two separate arrays. The first array contains values 
 *              evaluated as true while the second array houses the falsey values.
 * 
 * @param {Array} array: The array to partition. 
 * @param {Function} test: The function to test Array's values.
 * 
 * @return {Array}: An array containing two more arrays: the truthies separated from the falsies.
 * 
*/

partition = function(array, test) {
    let truthyArray = [];
    let falseyArray = [];

    each(array, function(element, i, array) {
        if (test(element, i, array)) {
            truthyArray.push(element);
        }
        else {
            falseyArray.push(element);
        }
    });
    return [truthyArray, falseyArray];
}

module.exports.partition = partition;

/** 
 * unique: Removes duplicate values from an array.
 * 
 * @param {Array} array
 * 
 * @return {Array}: A copy of original Array with the duplicates removed. 
 * 
 */

unique = function(array) {
    let newArray = [];

    each(array, function(element, i, array) {
        if (indexOf(newArray, element) === -1) {
            newArray.push(element);
        }
    });
    return newArray;
}

module.exports.unique = unique; 

/** 
 * map: Designed to take a collection and a function. It calls the function on 
 *      each and every item in the collection and then returns an array containing 
 *      the new values.
 * 
 * @param {Array or Object} collection: The collection of values to modify
 * @param {Function} action:            The function that will be called upon each element 
 * 
 * @return {Output Type}: A copy of the array with modified values.
 * 
 * 
 */
 map = function(collection, action) {
    let newArray = [];
        // if collection is an array
        if (Array.isArray(collection)) {
            for (let i = 0; i < collection.length; i++) {
                newArray.push(action(collection[i], i, collection));
            }

        }
        // if collection is an object
        else if (!Array.isArray(collection)) {
            for (var key in collection) {
                newArray.push(action(collection[key], key, collection))
            }
        }
    return newArray; 
}

module.exports.map = map;

/** 
 * pluck:   Takes an array of objects and returns value stored at the specified 
 *          property from every object.
 * 
 * @param {Array of Objects} arrayOfObjects: An array of objects to pluck values from.
 * @param {String} property:  The property whose values you want to collect.
 * 
 * @return {Array}: An array containing the value at the specified property for
 *                  every element in argument array
 * 
 * Usage:
 *          _.pluck([{a: "one"}, {a: "two"}], "a") -> ["one", "two"]
 */
 
pluck = function(arrayOfObjects, property) {
    let newArray = [];
    map(arrayOfObjects, function(element, index, collection) {
        newArray.push(element[property]);
    });
    return newArray;
}


module.exports.pluck = pluck;

/** 
 * contains:    Designed to loop through an array and tell whether a specified
 *              value exists in an array.
 * 
 * @param {Array} array:    The array to look through. 
 * @param value:            The value to find.
 * 
 * @return {Boolean}:   Returns true if the array contains the specified value and
 *                      false if the array doesn't contain the value.
 * 
 */

contains = function(array, value) {
    if (value !== undefined) {
        for (let i = 0; i < array.length; i++) {
            if (array[i] === value) {
                return true;
            }
        }
        return false;
    }
    else {
        return false;
    }
}

module.exports.contains = contains;

/** 
 * every:   Designed to figure out whether every element in a collection passes
 *          a test function. Loops through collection and returns false for the
 *          collection if any elements fail the test function. This function returns 
 *          true only if ALL the elements tested are true.
 * 
 * @param {Array or Object} collection: Collection to iterate over. Function can handle
 *                                      arrays and objects.
 * @param {Function} falseyTest: The function that will test each element in the array 
 *                              object. If this callback test function is not provided, 
 *                              the every function will simply loop through the collection
 *                              and return false if any of the elements are a falsey value 
 *                              (such as 0 or null).
 * 
 * @return {Boolean}:   The every function returns false if even just one of the iterated 
 *                      elements evaluates to false. If all of the elements are evaluated
 *                      to be true, the function returns true.
 * 
 *                      Note: This method returns true for empty collections because everything
 *                      is true of elements of empty collections.
 * Usage: 
 *   _.every([2,4,6], function(e){return e % 2 === 0}) -> true
 *   _.every([1,2,3], function(e){return e % 2 === 0}) -> false
 */


_.every = function(collection, falseyTest) {
  if (falseyTest !== undefined) {
    // loop through array elements and return false if loop hits a falsey
    if (Array.isArray(collection)) {
      for (let i = 0; i < collection.length; i++) {
        if (falseyTest(collection[i], i, collection) === false) {
            return false;
        }
      }
      return true;
    }
    // loop through object keys and return false is loop hits a falsey
    else if (_.typeOf(collection) === "object") {        
        for (var key in collection) {
            if (falseyTest(collection[key], key, collection) === false) {
                return false;
            }
        }
        return true;
    }
  } else {
    // loop through values
        for (let i = 0; i < collection.length; i++) {
        // return false is one of them is falsey
            if (collection[i] === false) {
                return false;
            }
        }
        // else return true
        return true;
  }
}

module.exports.every = every;

/** some:   Designed to figure out whether some elements in a collection meet a
 *          test function's criteria. Loops through collection and returns true for the
 *          collection if ANY elements pass the test function. This function returns 
 *          false only if ALL the elements tested return false.
 * 
 * @param {Array or Object} collection: Collection to iterate over. Can handle
 *                                      arrays and objects.
 * @param {Function} truthyTest: The function that will test each element in the array 
 *                              object. If this callback test function is not provided, 
 *                              the every function will simply loop through the collection
 *                              and return true if any of the elements are a truthy value 
 *                              (such as 0 or null).
 * 
 * @return {Boolean}:   The every function returns true if even just one of the iterated 
 *                      elements evaluates to true. If none of the elements pass the test,
 *                      the entire some function will return false.
 * 
 *                      Note: This method returns true for empty collections because everything
 *                      is true of elements of empty collections.
*/

_.some = function(collection, truthyTest) {
      if (truthyTest !== undefined) {
    // loop through array elements and return true if loop hits a truthy
    if (Array.isArray(collection)) {
      for (let i = 0; i < collection.length; i++) {
        if (truthyTest(collection[i], i, collection)) {
            return true;
        }
      }
      return false;
    }
    // loop through object keys and return true if loop hits a truthy
    else if (_.typeOf(collection) === "object") {        
        for (var key in collection) {
            if (truthyTest(collection[key], key, collection)) {
                return true;
            }
        }
        return false;
    }
  } else {
    // loop through values
        for (let i = 0; i < collection.length; i++) {
        // return true if even one of them is truthy
            if (collection[i] === true) {
                return true;
            }
        }
        // else return false
        return false;
  }
}

module.exports.some = some;

/** reduce: Shrinks a bunch of values into one value. Reduce takes an array of values,
 * a function that determines how to combine the values, and an initial value (seed). 
 * If the seed is not provided, the function takes the first element of the array
 * as the starting point. Each time the function loops, it uses the callback function
 * to combine the current element with the previous element. Reduce returns the final
 * value at the end of the loop.
 * 
 * @param {Array} array: The array to reduce
  @param {Function} accumulatorAsFunc: The function that will grow the seed value. 
  @param seed:  Optional starting value. You could set this to the datatype that
                you want the function to return.
  
  @return: the accumulated value at the end of the loop
  
  */

reduce = function(array, accumulatorAsFunc, seed) {
    // set seed to first element in array if left undefined
    for (let i = 0; i < array.length; i++) {
        if (seed === undefined) {
            seed = array[0];
        } else {        
        seed = accumulatorAsFunc(seed, array[i], i);
        }
    }
    return seed;
}

module.exports.reduce = reduce;

/** extend: This function will "extend" the first object argument to include
 * properties and values of subsequent arguments. 
 * If subsequent objects have the same property as the first object, 
 * the function will update that property to the subsequent object's value. If 
 * the subsequent objects have properties that the first object does not, the function
 * will write the new properties onto the object.
 * In short, this function mashes a bunch of objects together into a superobject. 
 * 
 * @param {Object} obj1: The object that will adopt properties and values from other objects
 * @param {Object(s)} objs: All of the objects that will be merged into the first object.
 * 
 * @return {Object}: An object that has adopted all of the properties and values.
 * 
 */

extend = function(obj1, ...objs) {
    for (let i = 0; i < objs.length; i++) {
        // loop through objs arguments
        for (var key in objs[i]) {
            // if objs[i] has a property that obj1 does not, add the property to obj1
            if (!obj1.hasOwnProperty(key)) {
                obj1[key] = objs[i][key];
            // else if obj[i] and obj1 have the same property, update obj1's property to obj[i]'s values
            } else if (obj1.hasOwnProperty(key)) {
                obj1[key] = objs[i][key];
            }
        }
    }
    return obj1;
 }


module.exports.extend = extend;
